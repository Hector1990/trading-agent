<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ä»»åŠ¡ {{ job_id }} - TradingAgents Console</title>
    <link rel="stylesheet" href="/static/css/style.css" />
</head>
<body class="detail-page">
    <nav class="top-nav">
        <span class="brand">TradingAgents Console</span>
        <div class="nav-right">
            {% if is_admin %}
            <a href="/metrics" class="text-link">ç›‘æ§é¢æ¿</a>
            <a href="/admin/users" class="text-link">ç”¨æˆ·ç®¡ç†</a>
            {% endif %}
            <span class="user-chip">ğŸ‘¤ {{ user }}</span>
            <a href="/logout" class="text-link">é€€å‡º</a>
        </div>
    </nav>
    <div class="detail-container" data-job-id="{{ job_id }}">
        <header class="detail-header">
            <div>
                <a href="/" class="back-link">â† è¿”å›ä»»åŠ¡é¢æ¿</a>
                <h1>ä»»åŠ¡ {{ job_id }}</h1>
                <p class="subtle" id="job-meta">åŠ è½½ä¸­...</p>
            </div>
            <span class="badge" id="job-status">pending</span>
        </header>

        <section class="detail-card">
            <h2>é˜¶æ®µè¿›åº¦</h2>
            <ul class="stage-list" id="stage-list"></ul>
        </section>

        <section class="detail-card">
            <h2>å®æ—¶è¾“å‡º</h2>
            <pre class="log-viewer" id="job-logs"></pre>
        </section>

        <section class="detail-card">
            <h2>æœ€ç»ˆæŠ¥å‘Š</h2>
            <div id="final-report" class="report-content"></div>
        </section>
    </div>

    <script>
        const stageConfig = [
            { key: 'market_report', label: 'å¸‚åœºåˆ†æ', patterns: [/Market Analyst/i, /å¸‚åœºåˆ†æå®Œæˆ/], reportKey: 'market_report' },
            { key: 'sentiment_report', label: 'ç¤¾äº¤æƒ…ç»ª', patterns: [/Social Analyst/i, /æƒ…ç»ªåˆ†æå®Œæˆ/], reportKey: 'sentiment_report' },
            { key: 'news_report', label: 'æ–°é—»æ´å¯Ÿ', patterns: [/News Analyst/i, /æ–°é—»åˆ†æå®Œæˆ/], reportKey: 'news_report' },
            { key: 'fundamentals_report', label: 'åŸºæœ¬é¢ç ”ç©¶', patterns: [/Fundamentals Analyst/i, /åŸºæœ¬é¢åˆ†æå®Œæˆ/], reportKey: 'fundamentals_report' },
            { key: 'investment_plan', label: 'ç ”ç©¶å›¢é˜Ÿæ€»ç»“', patterns: [/Bull Analyst/i, /Bear Analyst/i, /Research Manager/i, /ç ”ç©¶å›¢é˜Ÿæ€»ç»“å®Œæˆ/], reportKey: 'investment_plan' },
            { key: 'trader_investment_plan', label: 'äº¤æ˜“å‘˜æ‰§è¡Œ', patterns: [/Trader/i, /äº¤æ˜“å‘˜æ–¹æ¡ˆç”Ÿæˆå®Œæˆ/], reportKey: 'trader_investment_plan' },
            { key: 'final_trade_decision', label: 'é£é™©è¯„ä¼°', patterns: [/Risky Analyst/i, /Neutral Analyst/i, /Safe Analyst/i, /Risk Manager/i, /Risk Judge/i, /Portfolio Manager/i, /é£é™©è¯„ä¼°å®Œæˆ/], reportKey: 'final_trade_decision' },
        ];

        const detailContainer = document.querySelector('.detail-container');
        const jobId = detailContainer.dataset.jobId;
        const stageList = document.getElementById('stage-list');
        const logsView = document.getElementById('job-logs');
        const statusBadge = document.getElementById('job-status');
        const metaText = document.getElementById('job-meta');
        const finalReport = document.getElementById('final-report');

        const statusClass = (status) => ({
            queued: 'badge-queued',
            running: 'badge-running',
            completed: 'badge-success',
            failed: 'badge-failed'
        })[status] || 'badge-queued';

        const deriveStageStates = (lines, jobStatus, reports) => {
            const indices = new Map();
            lines.forEach((line, idx) => {
                stageConfig.forEach(stage => {
                    if (stage.patterns.some(pattern => pattern.test(line))) {
                        indices.set(stage.key, idx);
                    }
                });
            });

            const stageStates = stageConfig.map(stage => ({
                key: stage.key,
                label: stage.label,
                state: 'pending',
                reportKey: stage.reportKey,
            }));

            if (jobStatus === 'queued') {
                return stageStates;
            }

            if (jobStatus === 'failed') {
                const lastStage = [...indices.entries()].sort((a, b) => a[1] - b[1]).pop();
                stageStates.forEach(stage => {
                    if (indices.has(stage.key)) {
                        stage.state = 'done';
                    }
                });
                if (lastStage) {
                    const failedStage = stageStates.find(stage => stage.key === lastStage[0]);
                    if (failedStage) failedStage.state = 'failed';
                }
                return stageStates;
            }

            stageStates.forEach(stage => {
                if (reports && reports[stage.key]) {
                    stage.state = 'done';
                }
            });

            if (jobStatus === 'completed') {
                stageStates.forEach(stage => {
                    stage.state = 'done';
                });
                return stageStates;
            }

            const ordered = [...indices.entries()].sort((a, b) => a[1] - b[1]);
            const activeKey = ordered.length ? ordered[ordered.length - 1][0] : null;

            stageStates.forEach(stage => {
                if (indices.has(stage.key)) {
                    stage.state = 'done';
                }
            });
            if (activeKey) {
                const activeStage = stageStates.find(stage => stage.key === activeKey);
                if (activeStage) activeStage.state = 'active';
                let setActive = false;
                for (const stage of stageStates) {
                    if (stage.key === activeKey) {
                        setActive = true;
                    }
                    if (!setActive && stage.state === 'pending') {
                        stage.state = 'done';
                    }
                }
            }

            return stageStates;
        };

        const renderStages = (lines, status, reports) => {
            const stages = deriveStageStates(lines, status, reports.raw);
            stageList.innerHTML = '';
            const stateText = {
                pending: 'å¾…å¼€å§‹',
                active: 'è¿›è¡Œä¸­',
                done: 'å·²å®Œæˆ',
                failed: 'å¤±è´¥',
            };
            stages.forEach(stage => {
                const li = document.createElement('li');
                li.className = `stage stage-${stage.state}`;
                const header = document.createElement('div');
                header.className = 'stage-header';
                header.innerHTML = `<span>${stage.label}</span><span class="stage-label">${stateText[stage.state] || ''}</span>`;
                li.appendChild(header);

                const reportHtml = reports.html?.[stage.reportKey];
                const reportRaw = reports.raw?.[stage.reportKey];
                if (reportHtml || reportRaw) {
                    const details = document.createElement('details');
                    details.open = stage.state === 'active';
                    const summary = document.createElement('summary');
                    summary.textContent = 'æŸ¥çœ‹æŠ¥å‘Š';
                    details.appendChild(summary);
                    const content = document.createElement('div');
                    content.className = 'report-content';
                    if (reportHtml) {
                        content.innerHTML = reportHtml;
                    } else {
                        const pre = document.createElement('pre');
                        pre.textContent = reportRaw;
                        content.appendChild(pre);
                    }
                    details.appendChild(content);
                    li.appendChild(details);
                }

                stageList.appendChild(li);
            });
        };

        const pollJob = async () => {
            try {
                const res = await fetch(`/api/jobs/${jobId}`);
                if (res.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (!res.ok) throw new Error('status fetch failed');
                const job = await res.json();

                statusBadge.textContent = job.status;
                statusBadge.className = `badge ${statusClass(job.status)}`;
                metaText.textContent = `åˆ›å»ºï¼š${new Date(job.created_at).toLocaleString()} | æ›´æ–°ï¼š${new Date(job.updated_at).toLocaleString()}`;

                if (job.reports_html?.final_trade_decision) {
                    finalReport.innerHTML = job.reports_html.final_trade_decision;
                } else if (job.reports?.final_trade_decision) {
                    const pre = document.createElement('pre');
                    pre.textContent = job.reports.final_trade_decision;
                    finalReport.innerHTML = '';
                    finalReport.appendChild(pre);
                } else if (job.decision) {
                    finalReport.textContent = job.decision;
                } else {
                    finalReport.textContent = 'æš‚æ— ç»ˆç‰ˆæŠ¥å‘Š';
                }

                const logRes = await fetch(`/api/jobs/${jobId}/logs?limit=300`, { cache: 'no-store' });
                if (logRes.status === 401) {
                    window.location.href = '/login';
                    return;
                }
                if (logRes.ok) {
                    const payload = await logRes.json();
                    const lines = payload.lines || [];
                    logsView.textContent = lines.join('\n');
                    logsView.scrollTop = logsView.scrollHeight;
                    renderStages(lines, job.status, { html: job.reports_html || {}, raw: job.reports || {} });
                }

                if (!['completed', 'failed'].includes(job.status)) {
                    setTimeout(pollJob, 4000);
                }
            } catch (err) {
                metaText.textContent = 'åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚';
                console.error(err);
            }
        };

        pollJob();
    </script>
</body>
</html>
